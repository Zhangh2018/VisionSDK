DEFAULTS {  SRAM_BASE		= 0x0  SRAM_SIZE		= 0x10000  VECTOR_BASE		= 0x0  VECTOR_SIZE		= 0xC0  CRAM_START_ADDR	= 0x100  GRAPH_SIZE		= 0x4000  CRAM_SIZE		= SRAM_SIZE - GRAPH_SIZE - CRAM_START_ADDR  STACK_SIZE		= 0x400}
MEMORY {  m0_0_intvec:	ORIGIN = VECTOR_BASE,					LENGTH = VECTOR_SIZE  cram:		ORIGIN = CRAM_START_ADDR,				LENGTH = CRAM_SIZE - STACK_SIZE  stack:	ORIGIN = CRAM_START_ADDR + CRAM_SIZE - STACK_SIZE,	LENGTH = STACK_SIZE  graph:	ORIGIN = SRAM_BASE + SRAM_SIZE - GRAPH_SIZE,		LENGTH = GRAPH_SIZE}
//============================================// Program layout for running out of RAM.//============================================
SECTIONS{    .vectable					:{} > m0_0_intvec    .init					: { *(.init) } > cram    .text					: > .    .vletext					: > .    .syscall					: > .    .intercall                                  : > .    .interfunc					: > .    .fixaddr					: > .    .fixtype					: > .    .secinfo					: > .    .rodata					: > .    .sdabase			ALIGN(16)	: > .	    .sdata					: > .    .sdata2					: > .    .sbss					: > .    .data					:{}>.    .bss					:{}>.    .CodeRelocateRam				:{}>.
    .stack   PAD(STACK_SIZE)	ALIGN(8)	: {} > stack    .graph   					: {} > graph
    __ghsend_stack		= ADDR(stack);    __CM0_0_STACK_ADDRESS	= ENDADDR(stack);     M0_0_VECTOR_TABLE		= ADDR(.vectable);    DATA_SRAM			= ADDR(.data);    BSS_START			= ADDR(.bss);    BSS_END			= ENDADDR(.bss);    __graph_start		= ADDR(.graph);}