<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>ACF/APEX Kernel SDK: Lucas-Kanade</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">ACF/APEX Kernel SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Lucas-Kanade<div class="ingroups"><a class="el" href="group__optical__flow.html">Optical flow</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Lucas-Kanade method. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaef7e9a50b1781ed10a9570b44bee9e4e"><td class="memItemLeft" align="right" valign="top">KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#gaef7e9a50b1781ed10a9570b44bee9e4e">apu_lucas_kanade_mismatch</a> (&quot;   apu_lucas_kanade_mismatch  &quot;, 5, __port(__index(0), __identifier(&quot;OUT_DELTAK_GRADX_IM&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(1), __identifier(&quot;OUT_DELTAK_GRADY_IM&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(2), __identifier(&quot;IN_DELTA_K_IMG&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(3), __identifier(&quot;IN_GRAD_X&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(4), __identifier(&quot;IN_GRAD_Y&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16s), __e0_size(1, 1), __ek_size(1, 1)))</td></tr>
<tr class="memdesc:gaef7e9a50b1781ed10a9570b44bee9e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lucas-Kanade mismatch kernel metadata.  <a href="#gaef7e9a50b1781ed10a9570b44bee9e4e">More...</a><br /></td></tr>
<tr class="separator:gaef7e9a50b1781ed10a9570b44bee9e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711bd6acb06e4138ba2161d2457177f4"><td class="memItemLeft" align="right" valign="top">KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga711bd6acb06e4138ba2161d2457177f4">apu_lucas_kanade_accum_simple</a> (&quot;   apu_lucas_kanade_accum_simple  &quot;, 4, __port(__index(0),
__identifier(&quot;IN_OFFS_ETA_X_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(1),
__identifier(&quot;IN_OFFS_ETA_Y_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(2),
__identifier(&quot;OUT_DELTAK_GRADX_IM&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(<a class="el" href="group__bilinear__interpolation.html#gad773bc59edc65e0241cecc876a314b4c">ACCUM_TILE_SIZE_X</a>, <a class="el" href="group__bilinear__interpolation.html#ga9512556dbbfa3e571d10d476964f9b9b">ACCUM_TILE_SIZE_Y</a>)), __port(__index(3),
__identifier(&quot;OUT_DELTAK_GRADY_IM&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(<a class="el" href="group__bilinear__interpolation.html#gad773bc59edc65e0241cecc876a314b4c">ACCUM_TILE_SIZE_X</a>, <a class="el" href="group__bilinear__interpolation.html#ga9512556dbbfa3e571d10d476964f9b9b">ACCUM_TILE_SIZE_Y</a>)))</td></tr>
<tr class="memdesc:ga711bd6acb06e4138ba2161d2457177f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lucas-Kanade accumulated mismatch kernel metadata. Accumultated etaX = Sum_neigh(deltaKGradX), etaY = Sum_neigh(deltaKGradY) are computed. Neighborhoods are the chunks.  <a href="#ga711bd6acb06e4138ba2161d2457177f4">More...</a><br /></td></tr>
<tr class="separator:ga711bd6acb06e4138ba2161d2457177f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e01fda1b11f42fe3c85a52640f3415"><td class="memItemLeft" align="right" valign="top">KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga11e01fda1b11f42fe3c85a52640f3415">apu_lucas_kanade_offset_xOry</a> (&quot;   apu_lucas_kanade_offset_xOry  &quot;, 10, __port(__index(0), __identifier(&quot;OUT_OFFS_G_VECT&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(1), __identifier(&quot;OUT_OFFS_G_OFFS_VECT&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(2), __identifier(&quot;IN_OFFS_ETA_X_VECTOR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(3), __identifier(&quot;IN_OFFS_ETA_Y_VECTOR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(4), __identifier(&quot;IN_ACC_GRAD_XorY_SQR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(5), __identifier(&quot;IN_ACC_GRAD_XY&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(6), __identifier(&quot;IN_ACC_DET_G_INV&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(7), __identifier(&quot;IN_VALID_POINTS&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(8), __identifier(&quot;OUT_VALID_POINTS&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(9), __identifier(&quot;OUT_OFFS_ETA_NORM&quot;), __attributes(ACF_ATTR_SCL_OUT_STATIC_FIXED), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1)))</td></tr>
<tr class="memdesc:ga11e01fda1b11f42fe3c85a52640f3415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lucas-Kanade offset for X and Y kernel metadata.  <a href="#ga11e01fda1b11f42fe3c85a52640f3415">More...</a><br /></td></tr>
<tr class="separator:ga11e01fda1b11f42fe3c85a52640f3415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6974339ea6ed913df44767d2a123a291"><td class="memItemLeft" align="right" valign="top">KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga6974339ea6ed913df44767d2a123a291">apu_lucas_kanade_offset_xOry_unsigned</a> (&quot;   apu_lucas_kanade_offset_xOry_unsigned  &quot;, 10, __port(__index(0),
__identifier(&quot;OUT_OFFS_G_VECT&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(1),
__identifier(&quot;OUT_OFFS_G_OFFS_VECT&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(2),
__identifier(&quot;IN_OFFS_ETA_X_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(3),
__identifier(&quot;IN_OFFS_ETA_Y_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(4),
__identifier(&quot;IN_ACC_GRAD_XorY_SQR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(5),
__identifier(&quot;IN_ACC_GRAD_XY&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(6),
__identifier(&quot;IN_ACC_DET_G_INV&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(7),
__identifier(&quot;IN_VALID_POINTS&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d16u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(8),
__identifier(&quot;OUT_VALID_POINTS&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d16u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(9),
__identifier(&quot;OUT_OFFS_ETA_NORM&quot;),
__attributes(ACF_ATTR_SCL_OUT_STATIC_FIXED),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)))</td></tr>
<tr class="memdesc:ga6974339ea6ed913df44767d2a123a291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lucas-Kanade offset for either X or Y with unsigned inputs kernel metadata.  <a href="#ga6974339ea6ed913df44767d2a123a291">More...</a><br /></td></tr>
<tr class="separator:ga6974339ea6ed913df44767d2a123a291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805a563b044cda086a0065769b2aa710"><td class="memItemLeft" align="right" valign="top">KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga805a563b044cda086a0065769b2aa710">apu_transformCoordsToPointOffs</a> (&quot;   apu_transformCoordsToPointOffs  &quot;, 6, __port(__index(0), __identifier(&quot;Out_Offsets&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(1), __identifier(&quot;Out_ValidPts&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(2), __identifier(&quot;In_XCoords&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(3), __identifier(&quot;In_YCoords&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(4), __identifier(&quot;In_ValidPts&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1)), __port(__index(5), __identifier(&quot;InImgWH_TileWH_DataSz&quot;), __attributes(ACF_ATTR_SCL_IN_STATIC_FIXED), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(8, 1)))</td></tr>
<tr class="memdesc:ga805a563b044cda086a0065769b2aa710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform Coordinates kernel metainfo.  <a href="#ga805a563b044cda086a0065769b2aa710">More...</a><br /></td></tr>
<tr class="separator:ga805a563b044cda086a0065769b2aa710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cc5ed069f96de9cc6e808aab2a77ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#gae1cc5ed069f96de9cc6e808aab2a77ce">lucas_kanade_mismatch_filter</a> (vec32s *deltaK_GradX, vec32s *deltaK_GradY, vec32s *imgDeltaK, int16s inStrideWidth, int16s bw, int16s bh, int16s outStrideWidth, vec16s *gradX, vec16s *gradY)</td></tr>
<tr class="memdesc:gae1cc5ed069f96de9cc6e808aab2a77ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the mismatch vector of the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image.  <a href="#gae1cc5ed069f96de9cc6e808aab2a77ce">More...</a><br /></td></tr>
<tr class="separator:gae1cc5ed069f96de9cc6e808aab2a77ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga408b2ca066d683b0cdcfcfbd0ce5ce9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga408b2ca066d683b0cdcfcfbd0ce5ce9d">lucas_kanade_accum_filter</a> (vec32s *etaX, vec32s *etaY, int16s inStrideWidth, int16s bw, int16s bh, vec32s *deltaK_GradX, vec32s *deltaK_GradY)</td></tr>
<tr class="memdesc:ga408b2ca066d683b0cdcfcfbd0ce5ce9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the accumulated mismatch vector (over the whole chunk) of an input image and a second shifted input image.  <a href="#ga408b2ca066d683b0cdcfcfbd0ce5ce9d">More...</a><br /></td></tr>
<tr class="separator:ga408b2ca066d683b0cdcfcfbd0ce5ce9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8616e34f29b06bd470b94d91e177428e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga8616e34f29b06bd470b94d91e177428e">lucas_kanade_offset_filter_xOry</a> (vec32s *gOut, vec32s *gOutOffs, vec32s *etaX, vec32s *etaY, vec32s *accGradXorYSqr, vec32s *accgradXgradY, vec32u *accDetG_inv, vec16u *inValidPts, vec16u *outValidPts, vec32u *vEtaNorm, int16s bw, int16s bh, int16s inStrideLen, int16s outStrideLen)</td></tr>
<tr class="memdesc:ga8616e34f29b06bd470b94d91e177428e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image.  <a href="#ga8616e34f29b06bd470b94d91e177428e">More...</a><br /></td></tr>
<tr class="separator:ga8616e34f29b06bd470b94d91e177428e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb89e32a01792e7b1257f2d221b37ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#gacb89e32a01792e7b1257f2d221b37ea4">lucas_kanade_offset_filter_xOry_unsigned</a> (vec32s *gOut, vec32s *gOutOffs, vec32s *etaX, vec32s *etaY, vec32u *accGradXorYSqr, vec32s *accgradXgradY, vec32u *accDetG_inv, vec16u *inValidPts, vec16u *outValidPts, vec32u *vEtaNorm, int16s bw, int16s bh, int16s inStrideLen, int16s outStrideLen)</td></tr>
<tr class="memdesc:gacb89e32a01792e7b1257f2d221b37ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image. The gradient matrix values are unsigned.  <a href="#gacb89e32a01792e7b1257f2d221b37ea4">More...</a><br /></td></tr>
<tr class="separator:gacb89e32a01792e7b1257f2d221b37ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47adb24be937ae77b4989390d65fb710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga47adb24be937ae77b4989390d65fb710">transformCoordsToPointOffsets</a> (vec32u *lPointOffsets, vec16u *newValidPts, vec32s *xCoords, vec32s *yCoords, vec16u *validPoints, int32s imgWidth, int32s imgHeight, int32s tWidth, int32s tHeight, int32s dataSz, int16s bw, int16s bh, int16s inStrideWidth, int16s outStrideWidth)</td></tr>
<tr class="memdesc:ga47adb24be937ae77b4989390d65fb710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute from x,y image coordinates the byte offset inside a linear array.  <a href="#ga47adb24be937ae77b4989390d65fb710">More...</a><br /></td></tr>
<tr class="separator:ga47adb24be937ae77b4989390d65fb710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c2047c5fdd66c3f9f918e4c0a396c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga57c2047c5fdd66c3f9f918e4c0a396c3"></a>
KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><b>_kernel_info_apu_lucas_kanade_offset</b> (&quot;apu_lucas_kanade_offset&quot;, 9, __port(__index(0),
__identifier(&quot;OFFS_ETA_X_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(1),
__identifier(&quot;OFFS_ETA_Y_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(2),
__identifier(&quot;OUT_OFFS_G_X_VECT_HIGH&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(3),
__identifier(&quot;OUT_OFFS_G_X_VECT_LOW&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(4),
__identifier(&quot;OUT_OFFS_G_Y_VECT_HIGH&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(5),
__identifier(&quot;OUT_OFFS_G_Y_VECT_LOW&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(6),
__identifier(&quot;IN_ACC_GRAD_X_SQR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(7),
__identifier(&quot;IN_ACC_GRAD_Y_SQR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(8),
__identifier(&quot;IN_ACC_GRAD_XY&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)))</td></tr>
<tr class="separator:ga57c2047c5fdd66c3f9f918e4c0a396c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3cd529d9b7d6f773d1e0b3e0d2f5d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd3cd529d9b7d6f773d1e0b3e0d2f5d1"></a>
KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><b>_kernel_info_apu_lucas_kanade_offset_x</b> (&quot;apu_lucas_kanade_offset_x&quot;, 7, __port(__index(0),
__identifier(&quot;OFFS_ETA_X_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(1),
__identifier(&quot;OFFS_ETA_Y_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(2),
__identifier(&quot;OUT_OFFS_G_X_VECT_HIGH&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(3),
__identifier(&quot;OUT_OFFS_G_X_VECT_LOW&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(4),
__identifier(&quot;IN_ACC_GRAD_X_SQR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(5),
__identifier(&quot;IN_ACC_GRAD_Y_SQR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(6),
__identifier(&quot;IN_ACC_GRAD_XY&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)))</td></tr>
<tr class="separator:gafd3cd529d9b7d6f773d1e0b3e0d2f5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b9814ff3dc33058e4ef95e46ec0b7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4b9814ff3dc33058e4ef95e46ec0b7b"></a>
KERNEL_INFO&#160;</td><td class="memItemRight" valign="bottom"><b>_kernel_info_apu_lucas_kanade_offset_y</b> (&quot;apu_lucas_kanade_offset_y&quot;, 7, __port(__index(0),
__identifier(&quot;OFFS_ETA_X_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(1),
__identifier(&quot;OFFS_ETA_Y_VECTOR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(2),
__identifier(&quot;OUT_OFFS_G_Y_VECT_HIGH&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(3),
__identifier(&quot;OUT_OFFS_G_Y_VECT_LOW&quot;),
__attributes(ACF_ATTR_VEC_OUT),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(4),
__identifier(&quot;IN_ACC_GRAD_X_SQR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(5),
__identifier(&quot;IN_ACC_GRAD_Y_SQR&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32u),
__e0_size(1, 1),
__ek_size(1, 1)), __port(__index(6),
__identifier(&quot;IN_ACC_GRAD_XY&quot;),
__attributes(ACF_ATTR_VEC_IN),
__spatial_dep(0, 0, 0, 0),
__e0_data_type(d32s),
__e0_size(1, 1),
__ek_size(1, 1)))</td></tr>
<tr class="separator:gac4b9814ff3dc33058e4ef95e46ec0b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f177ef052fc71291a8676227b45b3e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__of__lucas__kanade.html#ga7f177ef052fc71291a8676227b45b3e9">lucas_kanade_offset_filter</a> (vec32s *gOutX_high, vec32u *gOutX_low, vec32s *gOutY_high, vec32u *gOutY_low, vec32s *etaX, vec32s *etaY, vec32u *accGradXSqr, vec32u *accGradYSqr, vec32s *accgradXgradY, int16s inStrideLen, int16s bw, int16s bh, int16s outStrideLen)</td></tr>
<tr class="separator:ga7f177ef052fc71291a8676227b45b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27552344d0128cf550346a1a6bd01b0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27552344d0128cf550346a1a6bd01b0f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lucas_kanade_offset_filter_x</b> (vec32s *gOutX_high, vec32u *gOutX_low, vec32s *etaInX, vec32s *etaInY, vec32u *gradXSqr, vec32u *gradYSqr, vec32s *gradXgradY, int16s inStrideLen, int16s bw, int16s bh, int16s outStrideLen)</td></tr>
<tr class="separator:ga27552344d0128cf550346a1a6bd01b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf969068fd7edf42c303b6af5e1f10a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf969068fd7edf42c303b6af5e1f10a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>lucas_kanade_offset_filter_y</b> (vec32s *gOutY_high, vec32u *gOutY_low, vec32s *etaInX, vec32s *etaInY, vec32u *gradXSqr, vec32u *gradYSqr, vec32s *gradXgradY, int16s inStrideLen, int16s bw, int16s bh, int16s outStrideLen)</td></tr>
<tr class="separator:gacf969068fd7edf42c303b6af5e1f10a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gad773bc59edc65e0241cecc876a314b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad773bc59edc65e0241cecc876a314b4c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ACCUM_TILE_SIZE_X</b></td></tr>
<tr class="separator:gad773bc59edc65e0241cecc876a314b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9512556dbbfa3e571d10d476964f9b9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9512556dbbfa3e571d10d476964f9b9b"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ACCUM_TILE_SIZE_Y</b></td></tr>
<tr class="separator:ga9512556dbbfa3e571d10d476964f9b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad773bc59edc65e0241cecc876a314b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad773bc59edc65e0241cecc876a314b4c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ACCUM_TILE_SIZE_X</b></td></tr>
<tr class="separator:gad773bc59edc65e0241cecc876a314b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9512556dbbfa3e571d10d476964f9b9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9512556dbbfa3e571d10d476964f9b9b"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>ACCUM_TILE_SIZE_Y</b></td></tr>
<tr class="separator:ga9512556dbbfa3e571d10d476964f9b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga711bd6acb06e4138ba2161d2457177f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KERNEL_INFO apu_lucas_kanade_accum_simple </td>
          <td>(</td>
          <td class="paramtype">&quot; apu_lucas_kanade_accum_simple &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">4&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(0), __identifier(&quot;IN_OFFS_ETA_X_VECTOR&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(1), __identifier(&quot;IN_OFFS_ETA_Y_VECTOR&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(2), __identifier(&quot;OUT_DELTAK_GRADX_IM&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(<a class="el" href="group__bilinear__interpolation.html#gad773bc59edc65e0241cecc876a314b4c">ACCUM_TILE_SIZE_X</a>, <a class="el" href="group__bilinear__interpolation.html#ga9512556dbbfa3e571d10d476964f9b9b">ACCUM_TILE_SIZE_Y</a>))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(3), __identifier(&quot;OUT_DELTAK_GRADY_IM&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(<a class="el" href="group__bilinear__interpolation.html#gad773bc59edc65e0241cecc876a314b4c">ACCUM_TILE_SIZE_X</a>, <a class="el" href="group__bilinear__interpolation.html#ga9512556dbbfa3e571d10d476964f9b9b">ACCUM_TILE_SIZE_Y</a>))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lucas-Kanade accumulated mismatch kernel metadata. Accumultated etaX = Sum_neigh(deltaKGradX), etaY = Sum_neigh(deltaKGradY) are computed. Neighborhoods are the chunks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUCAS_KANADE_ACCUM_SIMPLE_KN</td><td>Define for Kernel name </td></tr>
    <tr><td class="paramname">10</td><td>Number of ports </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_DELTAK_GRADX_IMG</td><td>Define for name of output vector of accumulated DeltaK*GradX values, i.e. dot product btw DeltaK and GradX matrices (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_DELTAK_GRADY_IMG</td><td>Define for name of output vector of accumulated DeltaK*GradY, i.e. dot product btw DeltaK and GradY matrices (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_DELTAK_IMG</td><td>Define for name of input image of the difference between this and the previous images (signed 32bit) </td></tr>
    <tr><td class="paramname">Port GRADIENT_MATRIX_KN_GRAD_X</td><td>Define for name of Gradient X input image (signed 16bit) </td></tr>
    <tr><td class="paramname">Port GRADIENT_MATRIX_KN_GRAD_Y</td><td>Define for name of Gradient Y input image (signed 16bit) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef7e9a50b1781ed10a9570b44bee9e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KERNEL_INFO apu_lucas_kanade_mismatch </td>
          <td>(</td>
          <td class="paramtype">&quot; apu_lucas_kanade_mismatch &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">5&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(0), __identifier(&quot;OUT_DELTAK_GRADX_IM&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(1), __identifier(&quot;OUT_DELTAK_GRADY_IM&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(2), __identifier(&quot;IN_DELTA_K_IMG&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(3), __identifier(&quot;IN_GRAD_X&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(4), __identifier(&quot;IN_GRAD_Y&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lucas-Kanade mismatch kernel metadata. </p>
<p>Calculate the mismatch vector of the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image (Eq. 30). Ouputs the images of dot products of DeltaK.*GradX and DeltaK.*GradY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUCAS_KANADE_MISMATCH_KN</td><td>Define for Kernel name </td></tr>
    <tr><td class="paramname">5</td><td>Number of ports </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_DELTAK_GRADX_IMG</td><td>Define for name of signed 32bit output image of DeltaK*GradX values, i.e. dot product btw DeltaK and GradX matrices </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_DELTAK_GRADY_IMG</td><td>Define for name of signed 32bit output imageof accumulated DeltaK*GradY, i.e. dot product btw DeltaK and GradY matrices </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_DELTAK_IMG</td><td>Define for name of input image (signed 32bit) of the difference between this and the previous images signed </td></tr>
    <tr><td class="paramname">Port GRADIENT_MATRIX_KN_GRAD_X</td><td>Define for name of Gradient X input image (signed 16bit) </td></tr>
    <tr><td class="paramname">Port GRADIENT_MATRIX_KN_GRAD_Y</td><td>Define for name of Gradient Y input image (signed 16bit) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga11e01fda1b11f42fe3c85a52640f3415"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KERNEL_INFO apu_lucas_kanade_offset_xOry </td>
          <td>(</td>
          <td class="paramtype">&quot; apu_lucas_kanade_offset_xOry &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">10&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(0), __identifier(&quot;OUT_OFFS_G_VECT&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(1), __identifier(&quot;OUT_OFFS_G_OFFS_VECT&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(2), __identifier(&quot;IN_OFFS_ETA_X_VECTOR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(3), __identifier(&quot;IN_OFFS_ETA_Y_VECTOR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(4), __identifier(&quot;IN_ACC_GRAD_XorY_SQR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(5), __identifier(&quot;IN_ACC_GRAD_XY&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(6), __identifier(&quot;IN_ACC_DET_G_INV&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(7), __identifier(&quot;IN_VALID_POINTS&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(8), __identifier(&quot;OUT_VALID_POINTS&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(9), __identifier(&quot;OUT_OFFS_ETA_NORM&quot;), __attributes(ACF_ATTR_SCL_OUT_STATIC_FIXED), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lucas-Kanade offset for X and Y kernel metadata. </p>
<p>Calculate the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image. [nuEtaX = (1/detG)* [accGradYSqr -accGradXY] * [nuEtaX nuEtaY] -accGradXY accGradXSqr] nuEtaY]</p>
<p>Calculate actually either: nuEtaX = (accGradYSqr*nuEtaX - accGradXY*nuEtaY)/detG or nuEtaY = (accGradXSqr*nuEtaY - accGradXY*nuEtaX)/detG</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUCAS_KANADE_OFFSET_XorY_KN</td><td>Define for Kernel name </td></tr>
    <tr><td class="paramname">10</td><td>Number of ports </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_G_OUT_VECT</td><td>Define for name of integer part of output offset vector (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_G_OUT_OFFS_VECT</td><td>Define for name of fractional part of output offset vector in Q3.28 fixed point format (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_ETA_X_VECT</td><td>Define for name of accumulated X component of mismatch vector (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_ETA_Y_VECT</td><td>Define for name of accumulated Y component of mismatch vector (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_ACC_GRAD_XorY_SQR</td><td>Define for name of accumulated either gradX*gradX or gradY*gradY of imgA cut out around selected points and accumulated over a neighborhood (unsigned 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_ACC_GRAD_XY</td><td>Define for name of accumulated gradX*gradY of imgA cut out around selected points and accumulated over a neighborhood (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_ACC_DETG_INV</td><td>Define for name of inverse of determinant of above G matrix of imgA cut out around selected points and accumulated over a neighborhood (unsigned 16bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_VALID_POINTS</td><td>Define for name of input boolean vector. Values are true, if the corresponding determinant value correspond to certain validity criteria(i.e. are high enough but not too high) (unsigned 16bit). </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OUT_VALID_POINTS</td><td>Define for name of output boolean vector. Values are true, if the corresponding determinant value correspond to certain validity criteria(i.e. are high enough but not too high). Is AND-ed with input valid points (unsigned 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OUT_ETA_NORM</td><td>Define for name of etaNorm vector containing the sum of 16*(gOut+gOutOffs)^2 over the whole vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6974339ea6ed913df44767d2a123a291"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KERNEL_INFO apu_lucas_kanade_offset_xOry_unsigned </td>
          <td>(</td>
          <td class="paramtype">&quot; apu_lucas_kanade_offset_xOry_unsigned &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">10&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(0), __identifier(&quot;OUT_OFFS_G_VECT&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(1), __identifier(&quot;OUT_OFFS_G_OFFS_VECT&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(2), __identifier(&quot;IN_OFFS_ETA_X_VECTOR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(3), __identifier(&quot;IN_OFFS_ETA_Y_VECTOR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(4), __identifier(&quot;IN_ACC_GRAD_XorY_SQR&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(5), __identifier(&quot;IN_ACC_GRAD_XY&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(6), __identifier(&quot;IN_ACC_DET_G_INV&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(7), __identifier(&quot;IN_VALID_POINTS&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(8), __identifier(&quot;OUT_VALID_POINTS&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(9), __identifier(&quot;OUT_OFFS_ETA_NORM&quot;), __attributes(ACF_ATTR_SCL_OUT_STATIC_FIXED), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lucas-Kanade offset for either X or Y with unsigned inputs kernel metadata. </p>
<p>Calculate the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image. [nuEtaX = (1/detG)* [accGradYSqr -accGradXY] * [nuEtaX nuEtaY] -accGradXY accGradXSqr] nuEtaY]</p>
<p>Calculate actually either: nuEtaX = (accGradYSqr*nuEtaX - accGradXY*nuEtaY)/detG or nuEtaY = (accGradXSqr*nuEtaY - accGradXY*nuEtaX)/detG</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUCAS_KANADE_OFFSET_XorY_KN</td><td>Define for Kernel name </td></tr>
    <tr><td class="paramname">10</td><td>Number of ports </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_G_OUT_VECT</td><td>Define for name of integer part of output offset vector (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_G_OUT_OFFS_VECT</td><td>Define for name of fractional part of output offset vector in Q3.28 fixed point format (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_ETA_X_VECT</td><td>Define for name of accumulated X component of mismatch vector (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OFFS_ETA_Y_VECT</td><td>Define for name of accumulated Y component of mismatch vector (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_ACC_GRAD_XorY_SQR</td><td>Define for name of accumulated either gradX*gradX or gradY*gradY of imgA cut out around selected points and accumulated over a neighborhood (unsigned 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_ACC_GRAD_XY</td><td>Define for name of accumulated gradX*gradY of imgA cut out around selected points and accumulated over a neighborhood (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_ACC_DETG_INV</td><td>Define for name of inverse of determinant of above G matrix of imgA cut out around selected points and accumulated over a neighborhood (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_VALID_POINTS</td><td>Define for name of input boolean vector. Values are true, if the corresponding determinant value correspond to certain validity criteria(i.e. are high enough but not too high) (unsigned 16bit). </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OUT_VALID_POINTS</td><td>Define for name of output boolean vector. Values are true, if the corresponding determinant value correspond to certain validity criteria(i.e. are high enough but not too high). Is AND-ed with input valid points (unsigned 16bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_KN_OUT_ETA_NORM</td><td>Define for name of etaNorm vector containing the sum of 16*(gOut+gOutOffs)^2 over the whole vector (unsigned 32bit) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga805a563b044cda086a0065769b2aa710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">KERNEL_INFO apu_transformCoordsToPointOffs </td>
          <td>(</td>
          <td class="paramtype">&quot; apu_transformCoordsToPointOffs &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">6&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(0), __identifier(&quot;Out_Offsets&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(1), __identifier(&quot;Out_ValidPts&quot;), __attributes(ACF_ATTR_VEC_OUT), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(2), __identifier(&quot;In_XCoords&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(3), __identifier(&quot;In_YCoords&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(4), __identifier(&quot;In_ValidPts&quot;), __attributes(ACF_ATTR_VEC_IN), __spatial_dep(0, 0, 0, 0), __e0_data_type(d16u), __e0_size(1, 1), __ek_size(1, 1))&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__port(__index(5), __identifier(&quot;InImgWH_TileWH_DataSz&quot;), __attributes(ACF_ATTR_SCL_IN_STATIC_FIXED), __spatial_dep(0, 0, 0, 0), __e0_data_type(d32s), __e0_size(1, 1), __ek_size(8, 1))&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform Coordinates kernel metainfo. </p>
<p>Helper kernel. Computes from x,y image coordinates the byte offset in the image. Outputs a vector of offsets. This is needed for indirect inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LUCAS_KANADE_OFFSET_TransfCoordsToOffs_KN</td><td>Define for Kernel name </td></tr>
    <tr><td class="paramname">6</td><td>Number of paramaters </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_OFFSET_TransfCoordsToOffs_OutOffsets</td><td>Define for name of output byte indices (unsigned 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_OFFSET_TransfCoordsToOffs_OutValidPts</td><td>Define for name of output flag array containing the valid points &amp; points inside the array boundaries. It is an AND-ed with the input valid points (unsigned 16bit). </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_OFFSET_TransfCoordsToOffs_XCoords</td><td>Define for name of array containing the x-Coordinates of the points (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_OFFSET_TransfCoordsToOffs_YCoords</td><td>Define for name of array containing the y-Coordinates of the points (signed 32bit) </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_OFFSET_TransfCoordsToOffs_InValidPts</td><td>Define for name of input flag array containing the valid points &amp; points inside the array boundaries (unsigned 16bit). </td></tr>
    <tr><td class="paramname">Port LUCAS_KANADE_OFFSET_TransfCoordsToOffs_StaticData</td><td>Define for name of input array of five elements containing imgWidth/Height, tileWidth/Height, overall data size (signed 32bit) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga408b2ca066d683b0cdcfcfbd0ce5ce9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lucas_kanade_accum_filter </td>
          <td>(</td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>inStrideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>deltaK_GradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>deltaK_GradY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the accumulated mismatch vector (over the whole chunk) of an input image and a second shifted input image. </p>
<p>(Eq.29)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nuEtaX</td><td>- [Output] accumulated X component of mismatch vector (nuEtaX = acc(deltaK*gradX)) </td></tr>
    <tr><td class="paramname">nuEtaY</td><td>- [Output] accumulated Y component of mismatch vector (nuEtaY = acc(deltaK*gradY)) </td></tr>
    <tr><td class="paramname">inStrideWidth</td><td>- [Input] Source block stride width (i.e. nr. of elements including padding) </td></tr>
    <tr><td class="paramname">bw</td><td>- [Input] Block width </td></tr>
    <tr><td class="paramname">bh</td><td>- [Input] Block height </td></tr>
    <tr><td class="paramname">deltaK_GradX</td><td>- [Input] x component of mismatch vector </td></tr>
    <tr><td class="paramname">deltaK_GradY</td><td>- [Input] y component of mismatch vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1cc5ed069f96de9cc6e808aab2a77ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lucas_kanade_mismatch_filter </td>
          <td>(</td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>deltaK_GradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>deltaK_GradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>imgDeltaK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>inStrideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>outStrideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16s *&#160;</td>
          <td class="paramname"><em>gradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16s *&#160;</td>
          <td class="paramname"><em>gradY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the mismatch vector of the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image. </p>
<p>( Eq 30)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deltaK_GradX</td><td>- [Output] 32bit Accumulated value for deltaK*gradX inside the current Chunk </td></tr>
    <tr><td class="paramname">deltaK_GradY</td><td>- [Output] 32bit Accumulated value for deltaK*gradY inside the current Chunk </td></tr>
    <tr><td class="paramname">inStrideWidth</td><td>- [Input] Source block stride width (i.e. nr. of elements including padding) </td></tr>
    <tr><td class="paramname">bw</td><td>- [Input] Block width </td></tr>
    <tr><td class="paramname">bh</td><td>- [Input] Block height </td></tr>
    <tr><td class="paramname">outStrideWidth</td><td>- [Input] Destination block stride width (i.e. nr. of elements including padding) </td></tr>
    <tr><td class="paramname">imgDeltaK</td><td>- [Input] 32bit (temporal) Difference of image patches from imgA cut out around selected points and interpolated ImgB cut out around SHIFTED selected points </td></tr>
    <tr><td class="paramname">gradX</td><td>- [Input] 32bit Gradient in X direction of imgA cut out around selected points </td></tr>
    <tr><td class="paramname">gradY</td><td>- [Input] 32bit Gradient in Y direction of imgA cut out around selected points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7f177ef052fc71291a8676227b45b3e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lucas_kanade_offset_filter </td>
          <td>(</td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>gOutX_high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>gOutX_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>gOutY_high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>gOutY_low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>accGradXSqr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>accGradYSqr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>accgradXgradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>inStrideLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>outStrideLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image. [nuEtaX = [accGradYSqr -accGradXY] * [nuEtaX nuEtaY] -accGradXY accGradXSqr] nuEtaY]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gOutX_high-[Output]</td><td>High word of 64bit X component of offsets vector </td></tr>
    <tr><td class="paramname">gOutX_low-</td><td>[Output] Low word of 64bit X component of offsets vector </td></tr>
    <tr><td class="paramname">gOutY_high-[Output]</td><td>High word of 64bit Y component of offsets vector </td></tr>
    <tr><td class="paramname">gOutY_low-</td><td>[Output] Low word of 64bit Y component of offsets vector </td></tr>
    <tr><td class="paramname">nuEtaX</td><td>- [Input] accumulated X component of mismatch vector </td></tr>
    <tr><td class="paramname">nuEtaY</td><td>- [Input] accumulated Y component of mismatch vector </td></tr>
    <tr><td class="paramname">sstr</td><td>- [Input] Source block stride </td></tr>
    <tr><td class="paramname">bw</td><td>- [Input] Block width </td></tr>
    <tr><td class="paramname">bh</td><td>- [Input] Block height </td></tr>
    <tr><td class="paramname">gradXSqr</td><td>- [Input] accumulated gradX*gradX of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">gradYSqr</td><td>- [Input] accumulated gradY*gradY of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">gradXgradY-[Input]</td><td>accumulated gradX*gradY of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">detG</td><td>- [Input] Determinant of above G matrix of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">vEtaNorm</td><td>- [Output] partial etaNorm vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8616e34f29b06bd470b94d91e177428e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lucas_kanade_offset_filter_xOry </td>
          <td>(</td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>gOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>gOutOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>accGradXorYSqr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>accgradXgradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>accDetG_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16u *&#160;</td>
          <td class="paramname"><em>inValidPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16u *&#160;</td>
          <td class="paramname"><em>outValidPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>vEtaNorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>inStrideLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>outStrideLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image. </p>
<p>[nuEtaX = (1/detG)* [accGradYSqr -accGradXY] * [nuEtaX nuEtaY] -accGradXY accGradXSqr] nuEtaY]</p>
<p>Either nuEtaX = (accGradYSqr*nuEtaX - accGradXY*nuEtaY)/detG or nuEtaY = (accGradXSqr*nuEtaY - accGradXY*nuEtaX)/detG</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gOut</td><td>- [Output] 32bit integer part of Offset </td></tr>
    <tr><td class="paramname">gOutOffs</td><td>- [Output] 32bit offset vector in Q3.28 fixed point format </td></tr>
    <tr><td class="paramname">etaX</td><td>- [Input] accumulated X component of mismatch vector </td></tr>
    <tr><td class="paramname">etaY</td><td>- [Input] accumulated Y component of mismatch vector </td></tr>
    <tr><td class="paramname">gradXorYSqr</td><td>- [Input] accumulated either gradX*gradX or gradY*gradY of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">gradXgradY</td><td>- [Input] accumulated gradX*gradY of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">accDetG_inv</td><td>- [Input] Inverse of Determinant of above G matrix of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">inValidPts</td><td>- [Input] Boolean vector. Values are true, if the corresponding determinant value correspond to certain validity criteria(i.e. are high enough but not too high). </td></tr>
    <tr><td class="paramname">outValidPts</td><td>- [Input] Boolean vector. Values are true, if the corresponding gOut are not too high. </td></tr>
    <tr><td class="paramname">vEtaNorm</td><td>- [Output] etaNorm vector containing the sum of 16*(gOut+gOutOffs)^2 over the whole vector </td></tr>
    <tr><td class="paramname">bw</td><td>- [Input] Block width </td></tr>
    <tr><td class="paramname">bh</td><td>- [Input] Block height </td></tr>
    <tr><td class="paramname">inStrideLen</td><td>- [Input] Source block stride width (in pixels not bytes!) </td></tr>
    <tr><td class="paramname">ouStrideLen</td><td>- [Input] Destination block stride width (in pixels not bytes!) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacb89e32a01792e7b1257f2d221b37ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lucas_kanade_offset_filter_xOry_unsigned </td>
          <td>(</td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>gOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>gOutOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>etaY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>accGradXorYSqr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>accgradXgradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>accDetG_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16u *&#160;</td>
          <td class="paramname"><em>inValidPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16u *&#160;</td>
          <td class="paramname"><em>outValidPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>vEtaNorm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>inStrideLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>outStrideLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the inner Lucas Kanade Kernel of selected points (with neighborhoods) of an input image and a second shifted input image. The gradient matrix values are unsigned. </p>
<p>[nuEtaX = (1/detG)* [accGradYSqr -accGradXY] * [nuEtaX nuEtaY] -accGradXY accGradXSqr] nuEtaY]</p>
<p>Either nuEtaX = (accGradYSqr*nuEtaX - accGradXY*nuEtaY)/detG or nuEtaY = (accGradXSqr*nuEtaY - accGradXY*nuEtaX)/detG</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gOut</td><td>- [Output] 32bit integer part of Offset </td></tr>
    <tr><td class="paramname">gOutOffs</td><td>- [Output] 32bit offset vector in Q3.28 fixed point format </td></tr>
    <tr><td class="paramname">etaX</td><td>- [Input] accumulated X component of mismatch vector </td></tr>
    <tr><td class="paramname">etaY</td><td>- [Input] accumulated Y component of mismatch vector </td></tr>
    <tr><td class="paramname">gradXorYSqr</td><td>- [Input] accumulated either gradX*gradX or gradY*gradY of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">gradXgradY</td><td>- [Input] accumulated gradX*gradY of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">accDetG_inv</td><td>- [Input] Inverse of Determinant of above G matrix of imgA cut out around selected points and accumulated over a neighborhood </td></tr>
    <tr><td class="paramname">inValidPts</td><td>- [Input] Boolean vector. Values are true, if the corresponding determinant value correspond to certain validity criteria(i.e. are high enough but not too high). </td></tr>
    <tr><td class="paramname">outValidPts</td><td>- [Input] Boolean vector. Values are true, if the corresponding gOut are not too high. </td></tr>
    <tr><td class="paramname">vEtaNorm</td><td>- [Output] etaNorm vector containing the sum of 16*(gOut+gOutOffs)^2 over the whole vector </td></tr>
    <tr><td class="paramname">bw</td><td>- [Input] Block width </td></tr>
    <tr><td class="paramname">bh</td><td>- [Input] Block height </td></tr>
    <tr><td class="paramname">inStrideLen</td><td>- [Input] Source block stride width (in pixels not bytes!) </td></tr>
    <tr><td class="paramname">ouStrideLen</td><td>- [Input] Destination block stride width (in pixels not bytes!) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga47adb24be937ae77b4989390d65fb710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void transformCoordsToPointOffsets </td>
          <td>(</td>
          <td class="paramtype">vec32u *&#160;</td>
          <td class="paramname"><em>lPointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16u *&#160;</td>
          <td class="paramname"><em>newValidPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>xCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec32s *&#160;</td>
          <td class="paramname"><em>yCoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec16u *&#160;</td>
          <td class="paramname"><em>validPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32s&#160;</td>
          <td class="paramname"><em>imgWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32s&#160;</td>
          <td class="paramname"><em>imgHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32s&#160;</td>
          <td class="paramname"><em>tWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32s&#160;</td>
          <td class="paramname"><em>tHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32s&#160;</td>
          <td class="paramname"><em>dataSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>inStrideWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16s&#160;</td>
          <td class="paramname"><em>outStrideWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute from x,y image coordinates the byte offset inside a linear array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lPointOffsets</td><td>- [Output] Byte indices inside the linear array of the (x,y)-(tWidth,tHeight) coordinate </td></tr>
    <tr><td class="paramname">newValidPts</td><td>- [Output] Flag array containing the validPts &amp; points inside the array boundaries. </td></tr>
    <tr><td class="paramname">xCoords</td><td>- [Input] Array containing the x-Coordinates of the points </td></tr>
    <tr><td class="paramname">yCoords</td><td>- [Input] Array containing the y-Coordinates of the points </td></tr>
    <tr><td class="paramname">validPoints</td><td>- [Input] Flag array being true for the points which have to be computed </td></tr>
    <tr><td class="paramname">imgWidth</td><td>- [Input] Image width </td></tr>
    <tr><td class="paramname">imgHeight</td><td>- [Input] Image height </td></tr>
    <tr><td class="paramname">tWidth</td><td>- [Input] Tile width </td></tr>
    <tr><td class="paramname">tHeight</td><td>- [Input] Tile height </td></tr>
    <tr><td class="paramname">dataSz</td><td>- [Input] <a class="el" href="structSize.html">Size</a> in bytes of the input data element </td></tr>
    <tr><td class="paramname">bw</td><td>- [Input] Block width </td></tr>
    <tr><td class="paramname">bh</td><td>- [Input] Block height </td></tr>
    <tr><td class="paramname">inStrideWidth</td><td>- [Input] Source block stride width (i.e. nr. of elements including padding) </td></tr>
    <tr><td class="paramname">outStrideWidth</td><td>- [Input] Destination block stride width (i.e. nr. of elements including padding) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 1 2016 10:05:08 for ACF/APEX Kernel SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
