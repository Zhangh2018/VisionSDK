/*****************************************************************************
*
* Freescale Confidential Proprietary
*
* Copyright (c) 2014 Freescale Semiconductor;
* All Rights Reserved
*
*****************************************************************************
*
* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
* THE POSSIBILITY OF SUCH DAMAGE.
*
****************************************************************************/
#ifndef APU_CONVOLUTION_PROCESS_H
#define APU_CONVOLUTION_PROCESS_H

#include "base_process_init.h"
#include "apu_convolution_graph.h"

#ifdef APEX2_EMULATE
#include "apu_convolution_apu_process_desc.hpp"
REGISTER_PROCESS_TYPE(CONVOLUTION_PI, apu_convolution_apu_process_desc)
#else
#include str_header(CONVOLUTION_PI,hpp)
#endif

// ////////Includes for convolution
#include "c_filter.hpp"
using namespace Convolution;
#include "../../../kernels/apu/filtering_kernels/src/symmetry_flags.h"

template <int filtW, int filtH, class dataTp>
class CConvolution_Proc : public CBase_ProcInit<CONVOLUTION_PI> {
private:
public:	// Input params
	
	DataDescriptor *lInput;

	/*Output data is generated by this process*/
	DataDescriptor lOutput;
	
	DataDescriptor filtData;
	DataDescriptor filtScale;
	//DataDescriptor filtWidth;
	//DataDescriptor filtHeight;
	DataDescriptor filtSymFlag;
	
public:
	CConvolution_Proc(int apex_id = APEX_APEX0)
	: CBase_ProcInit<CONVOLUTION_PI>(apex_id)
	{		
	}

	CConvolution_Proc(DataDescriptor *input, const CFilter<filtW, filtH, dataTp>* filt, int apex_id = APEX_APEX0)
		: CBase_ProcInit<CONVOLUTION_PI>(apex_id)
	{
		InitData(input, filt);
		Connect();
	}
		
	virtual ~CConvolution_Proc();

	int InitData(DataDescriptor *input, const CFilter<filtW, filtH, dataTp>* filt);

	int Connect();
	
};

#include "apu_convolution_graph.h"


template <int filtW, int filtH, class dataTp>
CConvolution_Proc<filtW, filtH, dataTp>::~CConvolution_Proc()
{
	lOutput.SetFreeOnExit(true);
	filtData.SetFreeOnExit(true);
	//filtWidth.SetFreeOnExit(true);
	//filtHeight.SetFreeOnExit(true);
	filtScale.SetFreeOnExit(true);
	filtSymFlag.SetFreeOnExit(true);
}

template <int filtW, int filtH, class dataTp>
int CConvolution_Proc<filtW, filtH, dataTp>::InitData(DataDescriptor *input, const CFilter<filtW, filtH, dataTp>* filt)
{
	lInput = input;

	size_t		 filtSz = filt->size();

	lOutput.Init(lInput->GetWidth(), lInput->GetHeight(), DATATYPE_16S);
	memset(lOutput.GetDataPtr(), '\0', lOutput.GetSpanRow()*lOutput.GetHeight());

	
	filtData.Init(1, 1, DATATYPE_16S, filtW, filtH);
	//filtWidth.Init(1, 1, DATATYPE_16U);
	//filtHeight.Init(1, 1, DATATYPE_16U);
	filtScale.Init(1, 1, DATATYPE_16S);
	filtSymFlag.Init(1, 1, DATATYPE_16U);

	m_errVal |= !(lOutput.IsOK());
	m_errVal |= !(filtData.IsOK());
	m_errVal |= !(filtScale.IsOK());
	m_errVal |= !(filtSymFlag.IsOK());
	
	memcpy(filtData.GetDataPtr(), filt->dataVect(), filtSz);
	//((unsigned short*)filtWidth.GetDataPtr())[0] = (unsigned short) filt->width();
	//((unsigned short*)filtHeight.GetDataPtr())[0] = (unsigned short) filt->height();
	((short*)filtScale.GetDataPtr())[0] = (short) filt->ScalingFact();

	((unsigned short*)filtSymFlag.GetDataPtr())[0] = SYMMFLAG(filt->isSymX(), filt->isSymY(), filt->isAntiSymX(), filt->isAntiSymY());

	return m_errVal;
	
}


template <int filtW, int filtH, class dataTp>
int CConvolution_Proc<filtW, filtH, dataTp>::Connect()
{

#ifdef APEX2_EMULATE
	cout << "\nInitializing graph:" << CONVOLUTION_GN << endl;
#endif

	m_errVal |= Initialize();

	m_errVal |= ConnectIO(CONVOLUTION_GRAPH_IN, *lInput);
	m_errVal |= ConnectIO(CONVOLUTION_GRAPH_OUT, lOutput);
	m_errVal |= ConnectIO(CONVOLUTION_GRAPH_IN_FILTER, filtData);

	//m_errVal |= ConnectIO(CONVOLUTION_GRAPH_FILTER_WIDTH, filtWidth);
	//m_errVal |= ConnectIO(CONVOLUTION_GRAPH_FILTER_HEIGHT, filtHeight);
	m_errVal |= ConnectIO(CONVOLUTION_GRAPH_FILTER_SCALE, filtScale);
	m_errVal |= ConnectIO(CONVOLUTION_GRAPH_FILTER_SYMMFLG, filtSymFlag);


#ifdef APEX2_EMULATE
	cout << CONVOLUTION_GN << " graph Plan: " << endl;
	cout << GetExecutionPlanDescription() << endl;
#endif


#ifdef APEX2_EMULATE
	if (m_errVal)
	{
		std::cout << CONVOLUTION_GN << " plan error!" << endl;
		std::cout << ErrorMessage() << endl;
		char c;
		std::cin >> c;
	}
#endif

	return m_errVal;
}




#endif
